'''
Created on Apr 19, 2014
 
@author: optas
'''
 
 
import numpy as np
import socket

import matplotlib 
if socket.gethostname()[0:6] == "madmax":
    matplotlib.use('Agg')
else:
    from mpl_toolkits.mplot3d import Axes3D  # @UnresolvedImport

import matplotlib.pyplot as plt 
import pylab as plb


from scipy import linspace


 
def topKVsAccuracy(graphName, topKs, accuracies, legendlabel, stamp="r*", save=False, saveAt=None):
    #How Accuracy varies when we change the -topK-
    plb.figure()    
    plb.xlim(xmin = 0.5, xmax = len(accuracies) + 0.5)               
    plb.ylim(ymin = min(accuracies) - 0.10, ymax = min(max(accuracies) + 0.10, 1.01) )
    plb.plot(range(1, len(topKs)+1), accuracies, stamp)
    plb.xticks(range(1, len(topKs)+1), topKs)    
    plb.xlabel("TopK")
    plb.ylabel("Precision of kernel matching")
    plb.title("<Graph = "+graphName+">  k of TopK Vs. Matching Accuracy")
    plb.legend(legendlabel, 3)
     
    legendlabel = '_'.join(legendlabel[0].split())
     
    if save:
        if saveAt != None:
            plb.savefig(saveAt)
        else:
            plb.savefig(graphName+"_TopKVSAccuracy_"+legendlabel+".png")
    else:        
        plb.show()
     
     
# 
# def xQuantityVsAccuracy-single(graphName, eigens, accuracies, legendlabel, stamp="r*", save=False, saveAt=None):
#     plb.figure()    
#     plb.xlim(xmin = 0.5, xmax = len(accuracies) + 0.5)               
#     plb.ylim(ymin = min(accuracies) - 0.10, ymax = min(max(accuracies) + 0.10, 1.01) )
#     plb.plot(range(1, len(eigens)+1), accuracies, stamp)
#     plb.xticks(range(1, len(eigens)+1), eigens)    
#     plb.xlabel("Number of Eigenvalues")
#     plb.ylabel("Precision of kernel matching")
#     plb.title("<Graph = "+graphName+">  Eigenvalues Vs. Matching Accuracy")
#     plb.legend(legendlabel, 3)
#     
#     legendlabel = '_'.join(legendlabel[0].split())
#     
#     if save:
#         if saveAt != None:
#             plb.savefig(saveAt)
#         else:
#             plb.savefig(graphName+"_EigensVSAccuracy_"+legendlabel+".png")
#     else:        
#         plb.show()
 
 
 
def xQuantityVsAccuracy(graphName, x, accuracies, xLabel, legendlabel, inText, stamp="-", save=False, saveAt=None):
    '''
    inText - String that will be a plotted along with the data. Also, if save=True and saveAt=None then 
    it will be part of the name of file that will be saved.   
    '''
    fig = plb.figure()    
    plb.xlim(xmin = 0.5, xmax = len(x) + 0.5)
     
    try:    #Accuracies, is a list of list, i.e., many plots to be plotted
        ymin = min(min(accuracies)) - 0.10
        ymax = max(max(accuracies)) + 0.10        
        plb.ylim(ymin, ymax = min(ymax, 1.01) )
        for i in xrange(len(accuracies)):
            plb.plot(range(1, len(x)+1), accuracies[i], stamp)
    except:
        ymin = min(accuracies) - 0.10
        ymax = max(accuracies) + 0.10        
        plb.ylim(ymin, ymax = min(ymax, 1.01) )
        plb.plot(range(1, len(x)+1), accuracies, stamp)
                                   
    plb.legend(legendlabel, 'best')
     
    if len(x) < 25:
        plb.xticks(range(1, len(x)+1), x)    
    else:
        plb.tick_params(axis='x', which='both', bottom='off',top='off',labelbottom='off') #turn of the ticks
 
    plb.xlabel("Number of "+xLabel)
    plb.ylabel("Precision of kernel matching")
    plb.title("<Graph = "+graphName+">  "+xLabel+" Vs. Matching Accuracy")
     
    fig.text(0.2, 0.2, inText)
     
    inText = '_'.join(inText.split())
     
    if save:
        if saveAt != None:
            plb.savefig(saveAt)
        else:
            plb.savefig(graphName+"_"+xLabel+"VSAccuracy_"+inText+".png")
    else:        
        plb.show()        
 
 
 
 
 
   
def plot_PCA_Res(cloudPoint, dim, legendLabel, colorMap=None, save=True, saveAt=None):
    '''
    Precondition -cloudPoing- is generated by: matplotlib.mlab.PCA()
    Input:
    -cloudPoint-   cloud of points as returned by matplotlib.mlab.PCA()
    -dim-          dimension of the projection space (1,2 or 3)
    -colorMap-     if None, must be a vector which describes the color assigned to every point of the cloudPoint (used for pro
    '''
    assert(dim in [1,2,3])
 
    fig = plt.figure()
 
    if dim == 1:
        y = [item[0] for item in cloudPoint.Y]
        x = linspace(min(y), max(y), len(y))
#         x = range(len(y))
        fig1 = plt.figure()
        if colorMap != None:            
            plt.scatter(x, y, color=colorMap[0])
        else:
            plt.scatter(x,y)
 
    elif dim == 2:
        x = []; y = [];
        for item in cloudPoint.Y:
            x.append(item[0])
            y.append(item[1])
            pltData = [x,y]
        fig1 = plt.figure()
        if colorMap != None:            
            plt.scatter(pltData[0], pltData[1], color=colorMap[0])
        else:
            plt.scatter(pltData[0], pltData[1])
         
        plt.xlabel("1st PC-axis") 
        plt.ylabel("2nd PC-axis")
        plt.title("2D PCA")
 
    elif dim == 3:
        x = []; y = []; z = [];
        for item in cloudPoint.Y:
            x.append(item[0])
            y.append(item[1])
            z.append(item[2])        
        pltData = [x,y,z]
        ax = Axes3D(fig)
        if colorMap != None:            
            ax.scatter(pltData[0], pltData[1], pltData[2], color=colorMap[0])            
        else:
            ax.scatter(pltData[0], pltData[1], pltData[2])
         
        # make simple, bare axis lines through space:
        xAxisLine = ((min(pltData[0]), max(pltData[0])), (0, 0), (0,0)) # 2 points make the x-axis line at the data extrema along x-axis 
        ax.plot(xAxisLine[0], xAxisLine[1], xAxisLine[2], 'r')          # make a red line for the x-axis.
        yAxisLine = ((0, 0), (min(pltData[1]), max(pltData[1])), (0,0))
        ax.plot(yAxisLine[0], yAxisLine[1], yAxisLine[2], 'r')
        zAxisLine = ((0, 0), (0,0), (min(pltData[2]), max(pltData[2])))
        ax.plot(zAxisLine[0], zAxisLine[1], zAxisLine[2], 'r')
     
        ax.set_xlabel("1st PC-axis") 
        ax.set_ylabel("2nd PC-axis")
        ax.set_zlabel("3rd PC-axis")
        ax.set_title("3D - PCA")
 
    if legendLabel != None:
        for i, legend in enumerate(legendLabel):
            fig.text(0.8, 0.8-(0.1 + 0.1*i), legend, color=colorMap[1][legend])
         
    if save:
        assert(saveAt != None)
        plt.savefig(saveAt)
    else:
        plt.show()
         

def barForTwo(d1, d2, ylabel, title, xTickMarks, width, legend=None, saveOut=None, d1Std=None, d2Std=None):
    fig = plt.figure()
    ax = fig.add_subplot(111)
 
    ## the data
    N = len(d1)
    ind = np.arange(N)                # the x locations for the groups
     
 
    if d1Std != None and d2Std != None:    
        rects1 = ax.bar(ind, d1, width, color='black', yerr=d1Std, error_kw=dict(elinewidth=2,ecolor='red'))
        rects2 = ax.bar(ind+width, d2, width, color='red', yerr=d2Std, error_kw=dict(elinewidth=2,ecolor='black'))
    else:    
        rects1 = ax.bar(ind, d1, width, color='black')
        rects2 = ax.bar(ind+width, d2, width, color='red')
         
 
    # axes and labels
    ax.set_xlim(-width,len(ind)+width)
    #ax.set_ylim(0,45)
    ax.set_ylabel(ylabel)
    ax.set_title(title)
    ax.set_xticks(ind+width)
    xtickNames = ax.set_xticklabels(xTickMarks)
    plt.setp(xtickNames, rotation=45, fontsize=10)
 
    ## add a legend
    if legend != None:
        ax.legend( (rects1[0], rects2[0]), (legend[0], legend[1]) )
    if saveOut != None:
        plt.savefig(saveOut)
    else:
        plt.show()
         
def colorMe():
    colors = ["blue", "green", "red", "cyan", "magenta", "yellow", "black", "white", 
               "burlywood", "chartreuse", "#FF00CC", "#FF6600"]
    for c in colors:
        yield c
         
 
def barForMany(inData, ylabel, title, xTickMarks, width, legend=None, saveOut=None, d1Std=None, d2Std=None):
    fig = plt.figure()
    col = colorMe()
    ax = fig.add_subplot(111)
 
    N   = len(inData)    #Number of groups
    K   = len(inData[0]) #Number of bars per group
    ind = np.arange(K)   # the x locations for the bars of the 1st group
     
    if d1Std != None and d2Std != None:    
        rects1 = ax.bar(ind, width, color='black', yerr=d1Std, error_kw=dict(elinewidth=2,ecolor='red'))
        rects2 = ax.bar(ind+width, width, color='red', yerr=d2Std, error_kw=dict(elinewidth=2,ecolor='black'))
    else:
        rects = []
        for i in range(len(inData)):
            rects.append(ax.bar(ind+(i*width), inData[i], width, color=col.next()))
         
 
    ax.set_ylabel(ylabel)
    ax.set_title(title)
    ax.set_xticks(ind+(0.6*width*np.floor(K/2)))
    xtickNames = ax.set_xticklabels(xTickMarks)
    plt.setp(xtickNames, rotation=45, fontsize=10)
 
    if legend != None:    ## add a legend
        arg1 = ( rects[i][0] for i in range(len(inData)))
        arg2 = ( legend[i] for i in range(len(inData)))
        ax.legend(arg1, arg2, loc='best') 
         
    if saveOut != None:
        plt.savefig(saveOut)
    else:
        plt.show()        
         
 
def heatMap(distanceMatrix, save=False, saveAt=".pdf"):
    plt.figure()
    plt.imshow(distanceMatrix, interpolation = 'none')    
    plt.jet()
    plt.colorbar()    
    if save:
        plt.savefig(saveAt)
    else:
        plt.show()
 
 
def x_vs_y(x, y, xAxisLabel=None, yAxisLabel=None, title=None, legendLabel=None, commentText=None, stamp="-", xTick=True, yNorm = False, save=False, saveAt=None):
    '''
     
    '''
    fig = plb.figure()    
 
    try:                #many y quantities
        if yNorm:
            ymin = min(min(y)) - 0.10
            ymax = max(max(y)) + 0.10        
            plb.ylim(ymin, ymax)
        plb.xlim(0.8, len(x)+1.2)
        for i in xrange(len(y)):
            plb.plot(range(1, len(x)+1), y[i], stamp)
             
    except:
        if yNorm:
            ymin = min(y) - 0.10
            ymax = max(y) + 0.10        
            plb.ylim(ymin, ymax)         
        plb.plot(range(1, len(x)+1), y, stamp)
         
 
    if legendLabel:
        plb.legend(legendLabel, 'best')
 
    if xTick:
        plb.xticks(range(1, len(x)+1), x, rotation=15)    
    else:
        plb.tick_params(axis='x', which='both', bottom='off',top='off',labelbottom='off') #turn of the ticks
 
 
    if xAxisLabel:
        plb.xlabel(xAxisLabel)
    if yAxisLabel:
        plb.ylabel(yAxisLabel)
    if title:
        plb.title(title)
 
    if commentText:
        fig.text(0.2, 0.2, commentText)
 
    if save:
        plb.savefig(saveAt)
    else:        
        plb.show()        
 

# def print_roles_of_nodes(inGraph):
    

def print_as_latex_table(table, headers):
    try:
        from tabulate import tabulate
        print tabulate(table, headers, tablefmt="latex")
    except:
        print 'tabulate not installed.'
        import sys
        sys.exit()
            

if __name__ == "__main__":
    pass